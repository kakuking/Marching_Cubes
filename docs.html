<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Room</title>
</head>

<!-- To get lato -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=DotGothic16&family=Lato:ital,wght@0,300;0,400;1,300&display=swap" rel="stylesheet">

<style>
    body {
        font-family: 'lato', sans-serif;
        background-color: #b5eaff;

        padding: 10px;
    }

    #header {
        display: flex;
        justify-content: center;
    }

    h1{
        text-decoration: double underline;
    }

    .production{
        text-align: center;
        font-size: large;
    }

    .controls{
        display: flex;
        justify-content: center;
    }

    .btnControl{
        background: none;
        border: solid 2px  #52cafa;
        font: inherit;
        cursor: pointer;

        padding: 10px;
        margin: 10px;

        transition: all 0.5s ease;
    }

    .btnControl:hover{
        background-color: #52cafa;
    }

    img {
        max-width: 70%;
        max-height: 100%;
    }

    .image{
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .iteration{
        text-align: center;
    }


</style>

<script>

    function sampleNext(aheadOrBack){
        let sampleImg = document.getElementById("sampleImg");
        let curImg = sampleImg.getAttribute('src');
        let curIt = +curImg.charAt(curImg.length - 5);
        curIt += aheadOrBack;
        let numOfThings = 7;
        curIt = curIt % numOfThings;

        if(curIt == -1 && aheadOrBack == -1){
            curIt = numOfThings - 1;
        }

        sampleImg.setAttribute('src', curImg.substring(0, curImg.length - 5) + curIt + ".jpg");
        
        
        if(curIt != 0){
            document.getElementById("sampleIteration").innerHTML
            = `${curIt}/${numOfThings}`;
        } else{
            document.getElementById("sampleIteration").innerHTML 
            = `${numOfThings}/${numOfThings}`
        }
    }

    function sampleNext1(aheadOrBack){
        let sampleImg = document.getElementById("sampleImg1");
        let curImg = sampleImg.getAttribute('src');
        let curIt = +curImg.charAt(curImg.length - 5);
        curIt += aheadOrBack;
        let numOfThings = 5;
        curIt = curIt % numOfThings;

        if(curIt == -1 && aheadOrBack == -1){
            curIt = numOfThings - 1;
        }

        sampleImg.setAttribute('src', curImg.substring(0, curImg.length - 5) + curIt + ".jpg");
        
        
        if(curIt != 0){
            document.getElementById("sampleIteration1").innerHTML
            = `${curIt}/${numOfThings}`;
        } else{
            document.getElementById("sampleIteration1").innerHTML 
            = `${numOfThings}/${numOfThings}`
        }
    }

    function sampleNext2(aheadOrBack){
        let sampleImg = document.getElementById("sampleImg2");
        let curImg = sampleImg.getAttribute('src');
        let curIt = +curImg.charAt(curImg.length - 5);
        curIt += aheadOrBack;
        let numOfThings = 4;
        curIt = curIt % numOfThings;

        if(curIt == -1 && aheadOrBack == -1){
            curIt = numOfThings - 1;
        }

        sampleImg.setAttribute('src', curImg.substring(0, curImg.length - 5) + curIt + ".jpg");
        
        
        if(curIt != 0){
            document.getElementById("sampleIteration2").innerHTML
            = `${curIt}/${numOfThings}`;
        } else{
            document.getElementById("sampleIteration2").innerHTML 
            = `${numOfThings}/${numOfThings}`
        }
    }

</script>

<body>
    <h1 id="header">An implementation of Marching Cubes with a demonstration of camera manipulation in OpenGL</h1>
    <h2 id="header">Kartikeya Dubey - 2020A7PS0031H</h2>
    <h3 id="header">Group E</h3>
    <div class="description">
        The Marching Cubes algorithm is a method to ascertain a 3D polygonal mesh from a discretely placed 
        scalar values. i.e., given a grid of points, this algorithm generates a polygonal mesh to encapsulate these points best.
        The algorithm has an ingenious method to do this, it splits the space into cubes to analyse. Each cube consists of 8 vertices (the values at which we are given, either 1 or 0).
        Then, depending on the configuration of the vertices which are 1 and which are 0, the mesh that lies completely within that cube is generated.
        Which this may result in 2<sup>8</sup> possibilities, they boil down to 15 unique configurations, the rest 
        are symmetries of the same. These 15 can be seen below: 
        <br>
    </div>
    <div class="controls">
        <button class="btnControl" onclick="sampleNext1(-1)">← Prev</button>
        <button class="btnControl" onclick="sampleNext1(1)">Next →</button>
    </div>
    <div class="image">
        <div id="sampleIteration1">1/5</div>
        <img id="sampleImg1" src="./Screenshots/Par1.jpg" alt="" srcset="">
    </div>
    
    <div class="production">
        glFrustum(-ar, ar, -1.0, 1.0, 2.0, 100.0);
    </div>
    <div class="description">Where <i>ar</i> is the aspect ratio of the window</div>
    <div class="controls">
        <button class="btnControl" onclick="sampleNext(-1)">← Prev</button>
        <button class="btnControl" onclick="sampleNext(1)">Next →</button>
    </div>
    <div class="image">
        <div id="sampleIteration">1/7</div>
        <img id="sampleImg" src="./Screenshots/Per1.jpg" alt="" srcset="">
    </div>

    <div class="description">
        <br>
        As can be seen, any wall/roof of the room that obstructs the camera does not render.
        <br>
        Moving on, we use perspective projection. To accomplish this, we use
        <br>
        <br>
    </div>
    <div class="production">
        glOrtho(-20, 20, -20, 30, 0, 100);
    </div>
    <div class="controls">
        <button class="btnControl" onclick="sampleNext1(-1)">← Prev</button>
        <button class="btnControl" onclick="sampleNext1(1)">Next →</button>
    </div>
    <div class="image">
        <div id="sampleIteration1">1/5</div>
        <img id="sampleImg1" src="./Screenshots/Par1.jpg" alt="" srcset="">
    </div>

    <div class="description">
        <br>
        However, in paralled projection, we run into an issue. Since there is no measure of depth as there is in perspective projection, 
        sometimes our function renders some walls/roofs that we think should not be rendered. This can be seen below, the first frame shows the
        erroneos versions, the second shows the proper image that can be obtained usually by moving the camera backwards along the n axis
    </div>

    <div class="controls">
        <button class="btnControl" onclick="sampleNext2(-1)">← Prev</button>
        <button class="btnControl" onclick="sampleNext2(1)">Next →</button>
    </div>
    <div class="image">
        <div id="sampleIteration2">1/4</div>
        <img id="sampleImg2" src="./Screenshots/ParError1.jpg" alt="" srcset="">
    </div>
    <h1 id="header">Thank You</h1>
</body>
</html>